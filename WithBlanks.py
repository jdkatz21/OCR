from __future__ import print_function
import os, io

from google.cloud import vision
import array

import layoutparser as lp
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import cv2
from pdf2image import convert_from_path

size = 3  # global constant for number of columns
start = [0, 1400]  # global constant for starting pt. of OCR
end = [2250, 5650]  # global constant for ending pt. of OCR

first_col_offset = 1500
num_cols = 3

# validate google ocr credentials
os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'ocr_key.json'

# create GCVAgent w/ key
ocr_agent = lp.GCVAgent.with_credential('ocr_key.json', languages=['it'])

# load and detect image
image = cv2.imread('1881_ex.png')

res = ocr_agent.detect('1881_ex.png', return_response=True)

# perform ocr on image
layout = ocr_agent.gather_full_text_annotation(res, agg_level=lp.GCVFeatureType.WORD)

###########################################################
# Use block of code to display image generated by OCR
image = lp.draw_text(image, layout, font_size=24, with_box_on_text=True,
                     text_box_width=1)
plt.imshow(image)
plt.show()
###########################################################


# creating filter for column 1, which is our base column
filtered_Col = layout.filter_by(
    lp.Rectangle(x_1=start[0], y_1=start[1], x_2=start[0] + first_col_offset, y_2=end[1])
)

####################################################
# group_blocks_by_distance takes in a column and a distance threshold, and then determines what

# left = the left-most coordinate of the interval to transcribe (does not include the base col)
# right = the right-most coordinate of the interval to transcribe
# top = the top of the interval to transcribe, should be taken from the base col
# bottom = the bottom of the interval to transcribe, should be taken from the base col
####################################################
def group_blocks_by_distance(col, th):
    col = sorted(col, key=lambda x: x.coordinates[1])
    distances = np.array([b2.coordinates[1] - b1.coordinates[3]
                          for (b1, b2) in zip(col, col[1:])])

    distances = np.append([0], distances)
    block_group = (distances > th).cumsum()

    grouped_blocks = [lp.Layout([]) for i in range(max(block_group) + 1)]
    for i, col in zip(block_group, col):
        grouped_blocks[i].append(col)

    return grouped_blocks


####################################################
# get_row takes in a left-most, right-most, top, and bottom rectangle for the row
# (not including the initial column) as well as how many columns are in the row
# (again, not including the initial column.
# Then, it loops through and appends each column of the row together.

# left = the left-most coordinate of the interval to transcribe (does not include the base col)
# right = the right-most coordinate of the interval to transcribe
# top = the top of the interval to transcribe, should be taken from the base col
# bottom = the bottom of the interval to transcribe, should be taken from the base col
####################################################
def get_row(left, right, top, bottom, num_col):
    #  First, calculates how much we have to shift in between columns

    shift_distance = (right - left) / num_col

    i = 0
    row = []

    while i < num_col:

        text_block = layout.filter_by(
            lp.Rectangle(x_1=left, y_1=bottom, x_2=left + shift_distance, y_2=top)
        )

        if text_block.get_texts():  # append to our col if there's text
            row.append(concatenate_list_data(text_block.get_texts()))
        else:
            row.append('')  # else add a blank space

        left += shift_distance  # shifts the column over to get the next col in the row
        i += 1

    return row


def concatenate_list_data(list):
    result = ''
    for element in list:
        result += str(element)
    return result


Col = group_blocks_by_distance(filtered_Col, -15)

result = []

for block in Col:
    if block.get_texts():
        row = []

        row.append(get_row(first_col_offset, end[0], block[0].points[2][1] + 20,
                           block[0].points[0][1] - 20, num_cols))
        row.insert(0, concatenate_list_data(block.get_texts()))
        result.append(row)

df = pd.DataFrame(result)


# appends the df created to a running excel doc
def append_df_to_excel(excel_path, df):
    df_excel = pd.read_excel(excel_path)
    result = pd.concat([df_excel, df], ignore_index=True)
    result.to_excel(excel_path, index=False)


append_df_to_excel('Output.xlsx', df)

print(df)
